install.packages("matrixstats")
install.packages("matrixstats")
install.packages("matrixStats")
install.packages(c("devtools","roxygen2","testthat","forecast","ggplot2","MASS","knitr","rmarkdown"))
devtools::document("hierCP")
clear
library("hierCP")
devtools::document("hierCP")
devtools::test("hierCP")
devtools::test()
devtools::test()
install.packages(c("devtools","roxygen2","testthat","forecast","ggplot2","MASS","knitr","rmarkdown"))
install.packages("matrixStats")
devtools::test()
# Pick bottom series = top 4 countries by revenue
top_countries <- retail %>%
group_by(Country) %>%
summarise(Rev = sum(Revenue, na.rm=TRUE), .groups="drop") %>%
arrange(desc(Rev)) %>%
slice_head(n = 4) %>%
pull(Country)
# devtools::document("hierCP"); devtools::load_all("hierCP")
library(hierCP)
# 1) Toy data
sim  <- sim_hier_data(Tn=120, nb=3)
Y    <- sim$Y; S <- sim$S; lev <- sim$levels
hier <- new_hierarchy(S, lev)
# 2) Level-wise beta suggestion (optional)
betas <- compute_level_penalties(Y, lev, eta = 1.0)
# 3) Changepoints (independent baseline)
taus <- detect_cp_independent(Y, lev, w = 15, cost = "mean")
devtools::document()
devtools::install()
library(readxl); library(dplyr); library(tidyr); library(lubridate)
# Load
raw <- readxl::read_excel("Online Retail.xlsx")
library(hierCP)
# --- 1) Get data (base R) ---
data("mdeaths"); data("fdeaths")  # monthly ts objects
# Put bottom series (columns) into a matrix (T x nb)
YB_mat <- cbind(mdeaths = as.numeric(mdeaths),
fdeaths = as.numeric(fdeaths))
nb <- ncol(YB_mat)
devtools::load_all(".")
library(hierCP)
# Simulate: Tn=120 time points, nb=3 bottom series
set.seed(123)
sim  <- sim_hier_data(Tn = 120, nb = 3)
Y    <- sim$Y        # T x p matrix (all series: bottom + aggregates)
S    <- sim$S        # Summing matrix
lev  <- sim$levels   # Hierarchy levels
hier <- new_hierarchy(S, lev)
dim(Y)          # rows = time, cols = all series
colnames(Y)     # bottom + higher levels
# Independent
taus_ind <- detect_cp_independent(Y, lev, w = 15, cost = "mean")
library(hierCP)
# Simulate: Tn=120 time points, nb=3 bottom series
set.seed(123)
sim  <- sim_hier_data(Tn = 120, nb = 3)
Y    <- sim$Y        # T x p matrix (all series: bottom + aggregates)
S    <- sim$S        # Summing matrix
lev  <- sim$levels   # Hierarchy levels
hier <- new_hierarchy(S, lev)
dim(Y)          # rows = time, cols = all series
colnames(Y)     # bottom + higher levels
# Independent
taus_ind <- detect_cp_independent(Y, lev, w = 15, cost = "mean")
# Top-down with alignment penalty
taus_td  <- detect_cp_topdown(Y, hier, eta = 2, w = 15,
soft_inherit_window = 3, cost = "mean")
# unzip hierCP_guarded.zip and setwd into the folder
devtools::document()
devtools::install()
# Re-run your code
taus_ind <- detect_cp_independent(Y, lev, w = 15, cost = "mean")
# 1) Find where hierCP is installed
.libPaths()
# 2) Remove the package
remove.packages("hierCP")
# 3) Delete any leftover lock folders (Windows leaves these sometimes)
locks <- list.files(.libPaths()[1], pattern = "^00LOCK", full.names = TRUE)
unlink(locks, recursive = TRUE, force = TRUE)
# 4) If the hierCP folder still exists in your library, delete it too
unlink(file.path(.libPaths()[1], "hierCP"), recursive = TRUE, force = TRUE)
library(hierCP)
taus_ind <- detect_cp_independent(Y, lev, w = 15, cost = "mean")
taus_ind <- detect_cp_independent(Y, lev, w = 15, cost = "mean")
set.seed(1)
x <- c(rnorm(40, 0), rnorm(40, 2))
# mean cost
detect_cp_window(x, w = 15, beta = log(length(x)), cost_fun = segment_cost_mean)
# gaussian cost
detect_cp_window(x, w = 15, beta = log(length(x)), cost_fun = segment_cost_gaussian)
# With a fussy align penalty that sometimes returns NA:
bad_align <- function(t) if (t %% 7 == 0) NA_real_ else abs(t - 35)/10
detect_cp_window(x, w = 15, beta = log(length(x)), cost_fun = segment_cost_mean,
align_penalty_fn = bad_align)
# demo_presentation.R
# Simulate 3 bottom series with a clear changepoint; build hierarchy; detect; forecast; show results.
source("hierarchy.R")
set.seed(42)
# --- simulate data ---
Tn <- 120; nb <- 3
# bottoms with a jump at t=70
b1 <- c(rnorm(70, 10, 2), rnorm(50, 14, 2))
b2 <- c(rnorm(70, 20, 3), rnorm(50, 25, 3))
b3 <- c(rnorm(70, 15, 2), rnorm(50, 18, 2))
YB <- cbind(b1, b2, b3)
# Summing matrix: rows = [b1; b2; b3; Total]
S <- rbind(diag(nb), rep(1, nb))
levels <- c(1L, 1L, 1L, 0L)                 # 0 = top
series_names <- c("b1","b2","b3","Total")
hier <- new_hierarchy(S, levels, series_names)
install.packages(c("devtools","roxygen2","testthat","forecast","ggplot2","MASS","knitr","rmarkdown"))
devtools::document()
devtools::document()
devtools::test()
clear
clss
cls
devtools::load_all(".")
# 1) Bottoms (T x 4)
YB <- as.matrix(EuStockMarkets)
colnames(YB) <- c("DAX","SMI","CAC","FTSE")
nb <- ncol(YB)
# 2) Summing matrix (rows = all series; cols = bottoms)
S <- rbind(diag(nb), rep(1, nb))  # b1,b2,b3,b4,Top
levels_vec <- c(rep(1L, nb), 0L)  # 0 = top
series_names <- c(colnames(YB), "EuropeTotal")
hier <- new_hierarchy(S, levels_vec, series_names)
# 3) Build all series (T x p)
Y <- YB %*% t(S)
colnames(Y) <- series_names  # names for convenience
# 4) Changepoints (no fancy args)
w <- 2
taus_ind <- detect_cp_independent(Y, hier$levels, w = w, cost = "mean")
system.time(detect_cp_window(Y[,1], w = w, cost_fun = segment_cost_mean))
devtools::load_all(".")
library(hierCP); data("EuStockMarkets")
# 1) Bottoms (T x 4)
YB <- as.matrix(EuStockMarkets)
colnames(YB) <- c("DAX","SMI","CAC","FTSE")
nb <- ncol(YB)
# 2) Summing matrix (rows = all series; cols = bottoms)
S <- rbind(diag(nb), rep(1, nb))  # b1,b2,b3,b4,Top
levels_vec <- c(rep(1L, nb), 0L)  # 0 = top
series_names <- c(colnames(YB), "EuropeTotal")
hier <- new_hierarchy(S, levels_vec, series_names)
# 3) Build all series (T x p)
Y <- YB %*% t(S)
colnames(Y) <- series_names  # names for convenience
w <- 2
taus_ind <- detect_cp_independent(Y, hier$levels, w = w, cost = "mean")
taus_td  <- detect_cp_topdown(Y, hier, eta = 2, w = w, cost = "mean")
print(taus_id)
print(taus_ind)
print(taus_td)
w <- 20
taus_ind <- detect_cp_independent(Y, hier$levels, w = w, cost = "mean")
taus_td  <- detect_cp_topdown(Y, hier, eta = 2, w = w, cost = "mean")
print(taus_td)
print(taus_ind)
taus_ind <- detect_cp_independent(Y, hier$levels, w = 20, cost = "gaussian")
print(taus_ind)
library(hierCP); data("EuStockMarkets")
# 1) Bottoms (T x 4)
YB <- as.matrix(EuStockMarkets)
colnames(YB) <- c("DAX","SMI","CAC","FTSE")
nb <- ncol(YB)
# 2) Summing matrix (rows = all series; cols = bottoms)
S <- rbind(diag(nb), rep(1, nb))  # b1,b2,b3,b4,Top
levels_vec <- c(rep(1L, nb), 0L)  # 0 = top
series_names <- c(colnames(YB), "EuropeTotal")
hier <- new_hierarchy(S, levels_vec, series_names)
# 3) Build all series (T x p)
Y <- YB %*% t(S)
colnames(Y) <- series_names  # names for convenience
# 4) Changepoints (no fancy args)
w <- 20
taus_ind <- detect_cp_independent(Y, hier$levels, w = w, cost = "mean")
taus_td  <- detect_cp_topdown(Y, hier, eta = 2, w = w, cost = "mean")
print(taus_ind)
# 5) Forecast with your package’s default reconciliation
h <- 10
res <- fit_forecast(Y, hier, h, strategy = "topdown")
# 6) Make sure forecasts have names (in case your build omitted them)
res$ytilde <- ensure_colnames(res$ytilde, series_names)
library(hierCP); data("EuStockMarkets")
# 1) Bottoms (T x 4)
YB <- as.matrix(EuStockMarkets)
colnames(YB) <- c("DAX","SMI","CAC","FTSE")
nb <- ncol(YB)
# 2) Summing matrix (rows = all series; cols = bottoms)
S <- rbind(diag(nb), rep(1, nb))  # b1,b2,b3,b4,Top
levels_vec <- c(rep(1L, nb), 0L)  # 0 = top
series_names <- c(colnames(YB), "EuropeTotal")
hier <- new_hierarchy(S, levels_vec, series_names)
# 3) Build all series (T x p)
Y <- YB %*% t(S)
colnames(Y) <- series_names  # names for convenience
# 4) Changepoints (no fancy args)
w <- 20
taus_ind <- detect_cp_independent(Y, hier$levels, w = w, cost = "mean")
taus_td  <- detect_cp_topdown(Y, hier, eta = 2, w = w, cost = "mean")
# 5) Forecast with your package’s default reconciliation
h <- 10
res <- fit_forecast(Y, hier, h, strategy = "topdown")
# 6) Make sure forecasts have names (in case your build omitted them)
res$ytilde <- ensure_colnames(res$ytilde, series_names)
# 7) Coherence check: Top equals sum of bottoms
if (!coherence_ok(res$ytilde, S)) {
stop("Coherence check failed: Top != sum(bottoms).")
} else {
cat("Coherence check passed: EuropeTotal == DAX+SMI+CAC+FTSE\n")
}
library(hierCP); data("EuStockMarkets")
# 1) Bottoms (T x 4)
YB <- as.matrix(EuStockMarkets)
colnames(YB) <- c("DAX","SMI","CAC","FTSE")
nb <- ncol(YB)
# 2) Summing matrix (rows = all series; cols = bottoms)
S <- rbind(diag(nb), rep(1, nb))  # b1,b2,b3,b4,Top
levels_vec <- c(rep(1L, nb), 0L)  # 0 = top
series_names <- c(colnames(YB), "EuropeTotal")
hier <- new_hierarchy(S, levels_vec, series_names)
# 3) Build all series (T x p)
Y <- YB %*% t(S)
colnames(Y) <- series_names  # names for convenience
# 4) Changepoints (no fancy args)
w <- 20
taus_ind <- detect_cp_independent(Y, hier$levels, w = w, cost = "mean")
taus_td  <- detect_cp_topdown(Y, hier, eta = 2, w = w, cost = "mean")
# 5) Forecast with your package’s default reconciliation
h <- 10
res <- fit_forecast(Y, hier, h, strategy = "topdown")
# 6) Make sure forecasts have names (in case your build omitted them)
res$ytilde <- ensure_colnames(res$ytilde, series_names)
# 7) Coherence check: Top equals sum of bottoms
if (!coherence_ok(res$ytilde, S)) {
stop("Coherence check failed: Top != sum(bottoms).")
} else {
cat("Coherence check passed: EuropeTotal == DAX+SMI+CAC+FTSE\n")
}
# 8) Quick look
print(round(head(res$ytilde, 3), 2))
library(hierCP); data("EuStockMarkets")
# 1) Bottoms (T x 4)
YB <- as.matrix(EuStockMarkets)
colnames(YB) <- c("DAX","SMI","CAC","FTSE")
nb <- ncol(YB)
# 2) Summing matrix (rows = all series; cols = bottoms)
S <- rbind(diag(nb), rep(1, nb))  # b1,b2,b3,b4,Top
levels_vec <- c(rep(1L, nb), 0L)  # 0 = top
series_names <- c(colnames(YB), "EuropeTotal")
hier <- new_hierarchy(S, levels_vec, series_names)
# 3) Build all series (T x p)
Y <- YB %*% t(S)
colnames(Y) <- series_names  # names for convenience
# 4) Changepoints (no fancy args)
w <- 20
taus_ind <- detect_cp_independent(Y, hier$levels, w = w, cost = "mean")
taus_td  <- detect_cp_topdown(Y, hier, eta = 2, w = w, cost = "mean")
# 5) Forecast with your package’s default reconciliation
h <- 10
res <- fit_forecast(Y, hier, h, strategy = "topdown")
# 6) Make sure forecasts have names (in case your build omitted them)
res$ytilde <- ensure_colnames(res$ytilde, series_names)
# 7) Coherence check: Top equals sum of bottoms
if (!coherence_ok(res$ytilde, S)) {
stop("Coherence check failed: Top != sum(bottoms).")
} else {
cat("Coherence check passed: EuropeTotal == DAX+SMI+CAC+FTSE\n")
}
# 8) Quick look
print(round(head(res$ytilde, 3), 2))
